# Read Lammps output files of thermal conductivity measurements
# Date: Februay 2017
# Author: Kutay B. Sezginel
import os
import math
import yaml
from teemof.reldist import reldist


k_parameters = dict(kb=0.001987, conv=69443.84, dt=5, volume=80 * 80 * 80, temp=300)


def read_thermal_flux(file_path, dt=k_parameters['dt'], start=200014, j_index=3):
    """Read thermal flux autocorellation vs time data from Lammps simulation output file

    Args:
        - file_path: Thermal flux autocorellation file generated by Lammps
        - dt: Time step
        - start: Index of the line to start reading flux autocorrelation (corresponds to last function)
        - j_index: Index of thermal flux in file

    Returns:
        - list: thermal flux autocorrelation function
        - list: time
    """
    with open(file_path, 'r') as f:
        flux_lines = f.readlines()
    flux, time = [], []
    for line in flux_lines[start:]:
        ls = line.split()
        t = (float(ls[0]) - 1) * dt / 1000.0
        flux.append(float(ls[j_index]))
        time.append(t)
    return flux, time


def calculate_k(flux, k_par=k_parameters):
    """Calculate thermal conductivity (W/mK) from thermal flux autocorrelation function

    Args:
        - flux (list): Thermal flux autocorellation read by read_thermal_flux method
        - k_par (dict): Dictionary of calculation parameters

    Returns:
        - list: Thermal conductivity autocorrelation function
    """
    k = flux[0] / 2 * k_par['volume'] * k_par['dt'] / (k_par['kb'] * math.pow(k_par['temp'], 2)) * k_par['conv']
    k_data = [k]
    for J in flux[1:]:
        k = k + J * k_par['volume'] * k_par['dt'] / (k_par['kb'] * math.pow(k_par['temp'], 2)) * k_par['conv']
        k_data.append(k)
    return k_data


def estimate_k(k_data, time, t0=5, t1=10):
    """ Get approximate thermal conductivity value for a single simulation.
    The arithmetic average of k values are taken between given timesteps.

    Args:
        - k_data (list): Thermal conductivity autocorrelation function
        - time (list): Simulation timestep
        - t0: Timestep to start taking average of k values
        - t1: Timestep to end taking average of k values

    Returns:
        - float: Estimate thermal conductivity
    """
    start, end = time.index(t0), time.index(t1)
    return (sum(k_data[start:end]) / len(k_data[start:end]))


def avg_kt(k_data_list):
    """ Calculate average of thermal conductivity for multiple runs """
    n = len(k_data_list[0])
    for i in k_data_list:
        m = len(i)
        if m != n:
            print('Data mismatch', i)
    avg_data = []
    for data_index in range(n):
        data = sum([i[data_index] for i in k_data_list]) / len(k_data_list)
        avg_data.append(data)
    return avg_data


def read_trials(mult_trial_dir, t0=4, t1=8, verbose=True):
    """ Read multiple trials with multiple runs"""
    trial_data = []
    trial_names = []
    for single_trial in os.listdir(mult_trial_dir):
        single_trial_dir = os.path.join(mult_trial_dir, single_trial)
        if os.path.isdir(single_trial_dir):
            run_data, time, runs_id = read_runs(single_trial_dir, t0=t0, t1=t1, verbose=verbose)
            trial_avg_kt = avg_kt(run_data)
            trial_data.append(trial_avg_kt)
        trial_names.append(single_trial)
    return trial_data, trial_names


def read_runs(trial_dir, t0=4, t1=8, verbose=True, k_par=k_parameters):
    """ Read multiple runs for single trial """
    print('\n------ %s ------' % os.path.split(trial_dir)[-1]) if verbose else None
    trial_data = []
    runs_id = []
    k_runs = []
    for run_index, run in enumerate(os.listdir(trial_dir)):
        run_dir = os.path.join(trial_dir, run)
        if os.path.isdir(run_dir):
            try:
                k_data_files, directions = check_kt_directions(run_dir)
                run_data = []
                for direc, data_path in zip(directions, k_data_files):
                    kt, time = read_thermal_flux(data_path)
                    kt = calculate_k(kt, k_par=k_par)
                    trial_data.append(kt)
                    run_data.append(kt)
                    runs_id.append('%s-%s' % (run, direc))
                run_avg_kt = avg_kt(run_data)
                k_run = estimate_k(run_avg_kt, time, t0=t0, t1=t1)
                k_runs.append(k_run)
                run_message = '%s -> kt: %.3f W/mK -> %i direction(s)' % (run, k_run, len(k_data_files))
                print(run_message) if verbose else None
            except Exception as e:
                print('%s -> Could not read, error: %s' % (run, e))
    trial_avg_kt = avg_kt(trial_data)
    k_trial = estimate_k(trial_avg_kt, time, t0=t0, t1=t1)
    print('Average -> %.3f W/mK from %i runs' % (k_trial, len(trial_data))) if verbose else None
    trial_results = dict(time=time, id=runs_id, k_runs=k_runs, k_trial=k_trial)
    # return trial_data, time, runs_id
    return trial_results


def read_single_run(run_dir, t0=4, t1=8, k_par=k_parameters, verbose=True):
    """ Read multiple runs for single trial """
    run = os.path.basename(run_dir)
    print('\n------ %s ------' % run) if verbose else None
    trial_data = []
    runs_id = []
    if os.path.isdir(run_dir):
        try:
            k_data_files, directions = check_kt_directions(run_dir)
            run_data = []
            for direc, data_path in zip(directions, k_data_files):
                kt, time = read_thermal_flux(data_path)
                kt = calculate_k(kt, k_par=k_par)
                trial_data.append(kt)
                run_data.append(kt)
                runs_id.append('%s-%s' % (run, direc))
            run_avg_kt = avg_kt(run_data)
            run_message = '%s -> kt: %.3f W/mK -> %i direction(s)' % (run, estimate_k(run_avg_kt, time), len(k_data_files))
            print(run_message) if verbose else None
        except Exception as e:
            print('%s -> Could not read, error: %s' % (run, e))
    trial_avg_kt = avg_kt(trial_data)
    approx_kt = estimate_k(trial_avg_kt, time, t0=t0, t1=t1)
    print('Average -> %.3f W/mK from %i runs' % (approx_kt, len(trial_data))) if verbose else None
    return trial_data, time, runs_id


def check_kt_directions(run_dir):
    """ Return thermal data for each direction as list """
    run_list = os.listdir(run_dir)
    k_list = []
    directions = []
    for f in run_list:
        if 'J0Jt_t' in f:
            k_list.append(os.path.join(run_dir, f))
            directions.append(f.split('.')[0].split('J0Jt_t')[1])
    return k_list, directions


def read_log(log_path, headers='Step Temp Press PotEng TotEng Volume'):
    """ Read log.lammps file and return lines for multiple thermo data """
    with open(log_path, 'r') as log:
        log_lines = log.readlines()

    thermo_start = []
    thermo_end = []
    for line_index, line in enumerate(log_lines):
        if headers in line:
            start = line_index + 1
            thermo_start.append(start)
        if 'Loop time' in line:
            end = line_index
            thermo_end.append(end)

    thermo_data = []
    for s, e in zip(thermo_start, thermo_end):
        thermo_data.append(log_lines[s:e])

    return thermo_data


def read_thermo(thermo_data, headers=['step', 'temp', 'press', 'tot_eng', 'volume']):
    """ Read thermo data from given thermo log lines """
    thermo = {key: [] for key in headers}
    for data in thermo_data:
        line = data.strip().split()
        for i, h in enumerate(headers):
            thermo[h].append(float(line[i]))

    return thermo


def read_run_info(run_dir):
    """ Read run info yaml file """
    run_info_path = os.path.join(run_dir, 'run_info.yaml')
    run_info = yaml.load(open(run_info_path, 'r'))
    return run_info


def read_legend(trial_dir, key='name', run='Run1'):
    """ Read legend name from given trial """
    if run is not None:
        run_dir = os.path.join(trial_dir, run)
    else:
        run_dir = trial_dir
    run_info = read_run_info(run_dir)
    return run_info[key]


def read_distance_runs(trial_dir, start=0, end=300000):
    """ Read relative distance data for given trial with multiple runs """
    hist_data = []
    for run in os.listdir(trial_dir):
        traj_path = os.path.join(trial_dir, run, 'traj.xyz')
        x_coords, y_coords, z_coords = reldist(traj_path, end=end)
        x_coords.append(0)
        x_coords.append(1)
        y_coords.append(0)
        y_coords.append(1)

        title = '%s' % run
        sort_param = int(run.split('Run')[1])
        hist_data.append((x_coords[start:], y_coords[start:], z_coords[start:], title, sort_param))

    return sorted(hist_data, key=lambda x: x[4])


def read_distance_trials(trial_set_dir, run='Run1', start=0, end=300000, xkey='sigma'):
    """ Read relative distance data for given trial set """
    hist_data = []
    for i, trial in enumerate(os.listdir(trial_set_dir), start=1):
        trial_dir = os.path.join(trial_set_dir, trial)
        traj_path = os.path.join(trial_dir, run, 'traj.xyz')
        x_coords, y_coords, z_coords = reldist(traj_path, end=end)
        x_coords.append(0)
        x_coords.append(1)
        y_coords.append(0)
        y_coords.append(1)

        leg = read_legend(trial_dir, key='legend')
        sort_param = read_legend(trial_dir, key=xkey)
        title = '%s' % leg
        hist_data.append((x_coords[start:], y_coords[start:], z_coords[start:], title, sort_param))

    return sorted(hist_data, key=lambda x: x[4])
